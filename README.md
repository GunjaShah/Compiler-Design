
# Toy Programming Language Compiler

### Compiler Design | Assignment 3 | Semester VII

## Objective
This project implements a basic compiler for a toy programming language. The language supports variable assignments, arithmetic operations, and conditional statements. The compiler consists of three main components: a lexer, a parser, and an interpreter, which work together to evaluate and execute programs written in this toy language.

## Table of Contents
- [Language Features](#language-features)
- [Project Structure](#project-structure)
- [Grammar Definition](#grammar-definition)
- [Components](#components)
  - [Lexer](#lexer-lexerpy)
  - [Parser](#parser-parserpy)
  - [Interpreter](#interpreter-interpreterpy)
- [How to Run](#how-to-run)
- [Example Program](#example-program)
- [Error Handling](#error-handling)
- [Conclusion](#conclusion)
- [Future Improvements](#future-improvements)

## Language Features
This toy programming language includes the following features:

- **Variable Assignment**: You can assign values to variables, e.g., `x = 5;`.
- **Basic Arithmetic Operations**: The language supports addition, subtraction, multiplication, and division, e.g., `x = 5 + 3;`.
- **Conditional Statements**: The language supports basic conditional expressions using `if` and `then` statements, e.g., `if x == 5 then y = 10;`.
- **Whitespace Insensitivity**: The language ignores spaces and tabs, making it flexible in terms of formatting.

## Project Structure
The project consists of the following files:
- **lexer.py**: Handles lexical analysis (tokenizing the source code).
- **parser.py**: Handles parsing (building an abstract syntax tree from tokens).
- **interpreter.py**: Handles interpretation (evaluating and executing the abstract syntax tree).
- **main.py**: Combines all components and runs the toy language.

## Grammar Definition
The grammar for the toy language includes the following rules:

```ebnf
statement   -> "if" condition "then" statement | assignment
assignment  -> IDENTIFIER "=" expression
expression  -> term (("+" | "-") term)*
term        -> factor (("*" | "/") factor)*
factor      -> NUMBER | IDENTIFIER | "(" expression ")"
condition   -> expression ("==" | "!=" | "<" | ">" | "<=" | ">=") expression
```

### Summary of Grammar:
- **Statement**: A statement can be either an assignment or a conditional statement.
- **Assignment**: Assigns the result of an expression to a variable.
- **Expression**: Supports basic arithmetic operations (+, -, *, /).
- **Condition**: Supports comparison operators (==, !=, <, >, <=, >=).

## Components

### Lexer (lexer.py)
The lexer reads the source code and converts it into a list of tokens representing individual components such as numbers, variables, operators, and keywords.

- **Key Features**:
  - Tokenizes variable identifiers, numbers, operators, and keywords.
  - Ignores whitespaces.
  - Raises an error for unrecognized characters.

### Parser (parser.py)
The parser takes tokens generated by the lexer and converts them into an abstract syntax tree (AST). This tree represents the hierarchical structure of the code.

- **Key Features**:
  - Parses assignment and arithmetic expressions.
  - Handles conditional statements (`if ... then`).
  - Constructs an abstract syntax tree (AST) for interpretation.

### Interpreter (interpreter.py)
The interpreter evaluates the abstract syntax tree and executes the program by interpreting AST nodes.

- **Key Features**:
  - Executes variable assignments and updates the symbol table.
  - Evaluates arithmetic expressions.
  - Evaluates conditions in `if` statements and executes corresponding code.

## How to Run

### Requirements:
- Python 3.x installed on your machine.

### Steps:
1. Clone or download this repository.
2. Ensure all Python files (`lexer.py`, `parser.py`, `interpreter.py`, and `main.py`) are in the same directory.
3. Run the `main.py` file to execute a toy language program:
```bash
python main.py
```

### Output:
After running `main.py`, you will see:
- A list of tokens generated by the lexer.
- An abstract syntax tree (AST) generated by the parser.
- The final state of variables after interpretation.

## Example Program
Here is a simple example of a program written in the toy language:

```plaintext
x = 5;
if x == 5 then y = 10;
```

### Sample Output:
```plaintext
Tokens: [('ID', 'x'), ('ASSIGN', '='), ('NUMBER', 5), ('END', ';'), ('IF', 'if'), ('ID', 'x'), ('EQ', '=='), ('NUMBER', 5), ('THEN', 'then'), ('ID', 'y'), ('ASSIGN', '='), ('NUMBER', 10), ('END', ';')]
AST: ('IF', ('BINOP', '==', ('VAR', 'x'), ('NUM', 5)), ('ASSIGN', 'y', ('NUM', 10)))
Final Variables: {'x': 5, 'y': 10}
```

In this example:
- The program assigns `x = 5`.
- The `if` condition is true (`x == 5`), so `y = 10` is executed.

## Error Handling
The toy compiler includes basic error handling for syntax issues:

- **Unexpected Token**: If the parser encounters a token that does not match the expected pattern, it will raise an error.
- **Lexical Errors**: If the lexer encounters an unrecognized character, it will raise an error.

## Conclusion
This toy programming language illustrates the key concepts of compiler design:

- **Lexical Analysis**: Tokenizing raw source code into meaningful tokens.
- **Parsing**: Building an abstract syntax tree (AST) from the tokens.
- **Interpretation**: Executing the AST to simulate the behavior of the program.

The project provides a foundation for understanding how compilers work and can be extended with more advanced features.

